import axios from 'axios';
import { promisify } from 'util';
import dns from 'dns';
import net from 'net';
import https from 'https';
import crypto from 'crypto';

const dnsResolve = promisify(dns.resolve);

// CVE veritabanı API endpoint'i
const CVE_API_URL = 'https://services.nvd.nist.gov/rest/json/cves/2.0';

// Yaygın güvenlik açıkları için kontrol noktaları
const COMMON_VULNERABILITIES = {
  'open-ports': {
    ports: [21, 22, 23, 25, 53, 80, 110, 135, 139, 443, 445, 1433, 1521, 3306, 3389, 5432, 8080],
    services: {
      21: 'FTP',
      22: 'SSH',
      23: 'Telnet',
      25: 'SMTP',
      53: 'DNS',
      80: 'HTTP',
      110: 'POP3',
      135: 'MSRPC',
      139: 'NetBIOS',
      443: 'HTTPS',
      445: 'SMB',
      1433: 'MSSQL',
      1521: 'Oracle',
      3306: 'MySQL',
      3389: 'RDP',
      5432: 'PostgreSQL',
      8080: 'HTTP-Proxy'
    }
  },
  'web-vulnerabilities': [
    { path: '/admin', risk: 'Medium', description: 'Potansiyel admin paneli tespit edildi' },
    { path: '/phpmyadmin', risk: 'High', description: 'phpMyAdmin arayüzü tespit edildi' },
    { path: '/wp-admin', risk: 'Medium', description: 'WordPress admin paneli tespit edildi' },
    { path: '/backup', risk: 'High', description: 'Potansiyel yedek dosyaları tespit edildi' }
  ]
};

async function checkPort(host, port) {
  return new Promise((resolve) => {
    const socket = new net.Socket();
    const timeout = 1000;

    socket.setTimeout(timeout);
    socket.on('connect', () => {
      socket.destroy();
      resolve(true);
    });

    socket.on('timeout', () => {
      socket.destroy();
      resolve(false);
    });

    socket.on('error', () => {
      socket.destroy();
      resolve(false);
    });

    socket.connect(port, host);
  });
}

async function scanWebVulnerabilities(target) {
  const vulnerabilities = [];
  const baseUrl = target.startsWith('http') ? target : `http://${target}`;

  for (const vuln of COMMON_VULNERABILITIES['web-vulnerabilities']) {
    try {
      const response = await axios.get(`${baseUrl}${vuln.path}`, {
        timeout: 5000,
        validateStatus: false
      });

      if (response.status !== 404) {
        vulnerabilities.push({
          id: `WEB-${Math.random().toString(36).substr(2, 9)}`,
          title: `Web Vulnerability: ${vuln.path}`,
          severity: vuln.risk,
          description: vuln.description,
          affectedComponents: `URL: ${baseUrl}${vuln.path}`,
          remediation: 'Erişimi kısıtlayın veya güvenlik önlemlerini artırın'
        });
      }
    } catch (error) {
      // İsteğin başarısız olması durumunda devam et
      continue;
    }
  }

  return vulnerabilities;
}

async function scanPorts(target) {
  const vulnerabilities = [];
  const openPorts = [];

  for (const port of COMMON_VULNERABILITIES['open-ports'].ports) {
    const isOpen = await checkPort(target, port);
    if (isOpen) {
      openPorts.push(port);
      const service = COMMON_VULNERABILITIES['open-ports'].services[port];
      vulnerabilities.push({
        id: `PORT-${port}`,
        title: `Açık Port: ${port} (${service})`,
        severity: port === 22 ? 'Medium' : port === 3389 ? 'High' : 'Low',
        description: `${service} servisi açık durumda`,
        affectedComponents: `Port ${port}`,
        remediation: 'Gereksiz ise portu kapatın veya erişimi kısıtlayın'
      });
    }
  }

  return { vulnerabilities, openPorts };
}

async function getCVEData(keyword, limit = 5) {
  try {
    console.log(`Fetching CVE data for keyword: ${keyword}`);
    const response = await axios.get(CVE_API_URL, {
      params: {
        keywordSearch: keyword,
        resultsPerPage: limit
      },
      headers: {
        'User-Agent': 'ReanzaiSecurityScanner/1.0'
      },
      timeout: 10000
    });

    if (response.data && response.data.vulnerabilities) {
      return response.data.vulnerabilities.map(vuln => ({
        id: vuln.cve.id,
        title: vuln.cve.descriptions.find(d => d.lang === 'en')?.value || 'No description available',
        severity: getCVSSSeverity(vuln.cve),
        cvssScore: getCVSSScore(vuln.cve),
        description: vuln.cve.descriptions.find(d => d.lang === 'en')?.value || 'No description available',
        affectedComponents: getAffectedComponents(vuln.cve),
        remediation: 'Etkilenen sistemleri güncelleyin ve yamaları uygulayın',
        publishedDate: vuln.cve.published,
        lastModifiedDate: vuln.cve.lastModified,
        references: vuln.cve.references?.map(ref => ref.url) || []
      }));
    }
    return [];
  } catch (error) {
    console.error('CVE API error:', error.message);
    return [];
  }
}

function getCVSSSeverity(cve) {
  // CVSS v3 öncelikli, yoksa v2
  const v3Metrics = cve.metrics?.cvssMetricV31 || cve.metrics?.cvssMetricV30;
  const v2Metrics = cve.metrics?.cvssMetricV2;
  
  if (v3Metrics && v3Metrics.length > 0) {
    return v3Metrics[0].cvssData?.baseSeverity || 'Unknown';
  } else if (v2Metrics && v2Metrics.length > 0) {
    const score = v2Metrics[0].cvssData?.baseScore || 0;
    if (score >= 9.0) return 'Critical';
    if (score >= 7.0) return 'High';
    if (score >= 4.0) return 'Medium';
    if (score > 0) return 'Low';
  }
  return 'Unknown';
}

function getCVSSScore(cve) {
  const v3Metrics = cve.metrics?.cvssMetricV31 || cve.metrics?.cvssMetricV30;
  const v2Metrics = cve.metrics?.cvssMetricV2;
  
  if (v3Metrics && v3Metrics.length > 0) {
    return v3Metrics[0].cvssData?.baseScore || 0;
  } else if (v2Metrics && v2Metrics.length > 0) {
    return v2Metrics[0].cvssData?.baseScore || 0;
  }
  return 0;
}

function getAffectedComponents(cve) {
  if (!cve.configurations || cve.configurations.length === 0) {
    return 'Unknown';
  }
  
  const components = [];
  cve.configurations.forEach(config => {
    if (config.nodes) {
      config.nodes.forEach(node => {
        if (node.cpeMatch) {
          node.cpeMatch.forEach(cpe => {
            if (cpe.criteria) {
              components.push(cpe.criteria);
            }
          });
        }
      });
    }
  });
  
  return components.length > 0 ? components.join(', ') : 'Unknown';
}

// Teknoloji sürümlerini tespit etme fonksiyonu
async function detectTechnologies(url) {
  try {
    const response = await axios.get(url, {
      timeout: 5000,
      validateStatus: false,
      headers: {
        'User-Agent': 'ReanzaiSecurityScanner/1.0'
      }
    });
    
    const technologies = [];
    const headers = response.headers;
    const html = response.data;
    
    // Server header'dan web sunucusu tespiti
    if (headers.server) {
      const serverHeader = headers.server.toLowerCase();
      if (serverHeader.includes('apache')) {
        const match = serverHeader.match(/apache\/([\d.]+)/i);
        technologies.push({
          name: 'Apache',
          version: match ? match[1] : 'Unknown',
          confidence: 'High'
        });
      } else if (serverHeader.includes('nginx')) {
        const match = serverHeader.match(/nginx\/([\d.]+)/i);
        technologies.push({
          name: 'Nginx',
          version: match ? match[1] : 'Unknown',
          confidence: 'High'
        });
      } else if (serverHeader.includes('microsoft-iis')) {
        const match = serverHeader.match(/microsoft-iis\/([\d.]+)/i);
        technologies.push({
          name: 'Microsoft IIS',
          version: match ? match[1] : 'Unknown',
          confidence: 'High'
        });
      }
    }
    
    // X-Powered-By header'dan teknoloji tespiti
    if (headers['x-powered-by']) {
      const poweredBy = headers['x-powered-by'].toLowerCase();
      if (poweredBy.includes('php')) {
        const match = poweredBy.match(/php\/([\d.]+)/i);
        technologies.push({
          name: 'PHP',
          version: match ? match[1] : 'Unknown',
          confidence: 'High'
        });
      } else if (poweredBy.includes('asp.net')) {
        const match = poweredBy.match(/asp\.net(?: ([\d.]+))?/i);
        technologies.push({
          name: 'ASP.NET',
          version: match && match[1] ? match[1] : 'Unknown',
          confidence: 'High'
        });
      }
    }
    
    // HTML içeriğinden teknoloji tespiti
    if (typeof html === 'string') {
      // WordPress tespiti
      if (html.includes('/wp-content/') || html.includes('/wp-includes/')) {
        let version = 'Unknown';
        const wpVersionMatch = html.match(/<meta name="generator" content="WordPress ([\d.]+)"/i);
        if (wpVersionMatch) {
          version = wpVersionMatch[1];
        }
        technologies.push({
          name: 'WordPress',
          version: version,
          confidence: 'High'
        });
      }
      
      // jQuery tespiti
      const jQueryMatch = html.match(/jquery[.-]?([\d.]+)(?:\.min)?\.js/i);
      if (jQueryMatch) {
        technologies.push({
          name: 'jQuery',
          version: jQueryMatch[1],
          confidence: 'Medium'
        });
      }
      
      // Bootstrap tespiti
      const bootstrapMatch = html.match(/bootstrap[.-]?([\d.]+)(?:\.min)?\.(?:js|css)/i);
      if (bootstrapMatch) {
        technologies.push({
          name: 'Bootstrap',
          version: bootstrapMatch[1],
          confidence: 'Medium'
        });
      }
      
      // React tespiti
      if (html.includes('react.js') || html.includes('react.min.js') || html.includes('react-dom')) {
        technologies.push({
          name: 'React',
          version: 'Unknown',
          confidence: 'Medium'
        });
      }
    }
    
    return technologies;
  } catch (error) {
    console.error('Technology detection error:', error.message);
    return [];
  }
}

// SSL/TLS kontrolü için yardımcı fonksiyon
async function checkSSL(url) {
  try {
    const response = await axios.get(url, {
      httpsAgent: new https.Agent({
        rejectUnauthorized: false,
        secureOptions: crypto.constants.SSL_OP_NO_TLSv1 | crypto.constants.SSL_OP_NO_TLSv1_1
      }),
      timeout: 5000
    });

    const issues = [];
    
    // Socket ve sertifika kontrolü
    if (response.request && response.request.res && response.request.res.socket) {
      const socket = response.request.res.socket;
      
      // Sertifika bilgilerini al
      if (socket.getPeerCertificate && typeof socket.getPeerCertificate === 'function') {
        const cert = socket.getPeerCertificate();
        
        if (cert && Object.keys(cert).length > 0) {
          // Sertifika geçerlilik kontrolü
          if (cert.valid_from && cert.valid_to) {
            const now = new Date();
            const validFrom = new Date(cert.valid_from);
            const validTo = new Date(cert.valid_to);

            if (now < validFrom) {
              issues.push({
                title: 'SSL Certificate Not Yet Valid',
                severity: 'High',
                cvssScore: 7.5,
                description: `SSL sertifikası henüz geçerli değil. Geçerlilik başlangıç tarihi: ${validFrom.toLocaleDateString()}`,
                remediation: 'Geçerli bir SSL sertifikası yükleyin.'
              });
            }

            if (now > validTo) {
              issues.push({
                title: 'SSL Certificate Expired',
                severity: 'Critical',
                cvssScore: 9.0,
                description: `SSL sertifikası süresi dolmuş. Son geçerlilik tarihi: ${validTo.toLocaleDateString()}`,
                remediation: 'SSL sertifikasını yenileyin.'
              });
            }
          }

          // Sertifika zinciri kontrolü
          if (!cert.issuerCertificate) {
            issues.push({
              title: 'Invalid SSL Certificate Chain',
              severity: 'High',
              cvssScore: 7.5,
              description: 'SSL sertifika zinciri geçersiz veya eksik.',
              remediation: 'Tam sertifika zincirini yükleyin.'
            });
          }

          // Sertifika algoritması kontrolü
          if (cert.signatureAlgorithm && 
             (cert.signatureAlgorithm.includes('sha1') || cert.signatureAlgorithm.includes('md5'))) {
            issues.push({
              title: 'Weak Certificate Signature Algorithm',
              severity: 'Medium',
              cvssScore: 5.0,
              description: `Zayıf sertifika imza algoritması kullanılıyor: ${cert.signatureAlgorithm}`,
              remediation: 'SHA-256 veya daha güçlü bir imza algoritması kullanan sertifika alın.'
            });
          }
        }
      }
      
      // Protokol kontrolü
      if (socket.getProtocol && typeof socket.getProtocol === 'function') {
        const protocol = socket.getProtocol();
        if (protocol === 'TLSv1' || protocol === 'TLSv1.1') {
          issues.push({
            title: 'Weak SSL/TLS Protocol',
            severity: 'High',
            cvssScore: 7.0,
            description: `Zayıf SSL/TLS protokolü kullanılıyor: ${protocol}`,
            remediation: 'TLS 1.2 veya TLS 1.3 kullanın ve eski protokolleri devre dışı bırakın.'
          });
        }
      }
    }
    
    // Protokol kontrolü yapılamadıysa genel bir uyarı ekle
    if (issues.length === 0) {
      // HTTPS kullanılıyor ama detaylı kontrol yapılamadı
      issues.push({
        title: 'SSL/TLS Configuration Check Limited',
        severity: 'Low',
        cvssScore: 2.0,
        description: 'SSL/TLS yapılandırması tam olarak kontrol edilemedi. Manuel olarak kontrol edilmesi önerilir.',
        remediation: 'SSL/TLS yapılandırmanızı SSL Labs gibi araçlarla kontrol edin.'
      });
    }

    return { issues };
  } catch (error) {
    console.error('SSL check error:', error);
    return { 
      issues: [{
        title: 'SSL/TLS Connection Error',
        severity: 'Medium',
        cvssScore: 5.0,
        description: `SSL/TLS bağlantısı sırasında hata oluştu: ${error.message}`,
        remediation: 'SSL/TLS yapılandırmanızı kontrol edin ve geçerli bir sertifika kullandığınızdan emin olun.'
      }] 
    };
  }
}

// CORS kontrolü için yardımcı fonksiyon
async function checkCORS(url) {
  try {
    // CORS başlıklarını kontrol et
    const response = await axios.get(url, {
      headers: {
        'Origin': 'https://example.com',
        'Access-Control-Request-Method': 'GET',
        'Access-Control-Request-Headers': 'X-Custom-Header'
      },
      validateStatus: false,
      timeout: 5000
    });
    
    const corsHeaders = {
      'access-control-allow-origin': response.headers['access-control-allow-origin'],
      'access-control-allow-methods': response.headers['access-control-allow-methods'],
      'access-control-allow-headers': response.headers['access-control-allow-headers'],
      'access-control-allow-credentials': response.headers['access-control-allow-credentials']
    };
    
    const issues = [];
    
    // CORS başlıkları var mı kontrol et
    if (corsHeaders['access-control-allow-origin']) {
      // Çok geniş CORS politikası kontrolü
      if (corsHeaders['access-control-allow-origin'] === '*') {
        issues.push({
          title: 'Permissive CORS Policy',
          severity: 'Medium',
          cvssScore: 5.0,
          description: 'CORS politikası tüm kaynaklara izin veriyor (*). Bu, kötü niyetli sitelerin API\'nize istek yapmasına izin verebilir.',
          remediation: 'CORS politikanızı sadece güvenilir kaynaklara izin verecek şekilde sınırlayın.'
        });
      }
      
      // Credentials ile birlikte wildcard kullanımı kontrolü
      if (corsHeaders['access-control-allow-origin'] === '*' && 
          corsHeaders['access-control-allow-credentials'] === 'true') {
        issues.push({
          title: 'Invalid CORS Configuration',
          severity: 'High',
          cvssScore: 7.0,
          description: 'CORS yapılandırması hem wildcard (*) hem de credentials:true kullanıyor. Bu geçersiz bir yapılandırmadır ve tarayıcılar tarafından reddedilir.',
          remediation: 'Credentials kullanırken, belirli bir origin belirtin, wildcard (*) kullanmayın.'
        });
      }
    }
    
    return { corsHeaders, issues };
  } catch (error) {
    console.error('CORS check error:', error.message);
    return { 
      corsHeaders: {}, 
      issues: [] 
    };
  }
}

// WAF (Web Application Firewall) tespiti için yardımcı fonksiyon
async function detectWAF(url) {
  try {
    // WAF tespiti için yaygın saldırı imzaları içeren istekler gönder
    const testPayloads = [
      { path: "/?q='OR 1=1--", type: "SQL Injection" },
      { path: "/?q=<script>alert(1)</script>", type: "XSS" },
      { path: "/?q=../../../etc/passwd", type: "Path Traversal" },
      { path: "/.git/HEAD", type: "Sensitive File" }
    ];
    
    let wafDetected = false;
    let wafType = 'Unknown';
    let wafEvidence = '';
    
    // Her test için istek gönder
    for (const test of testPayloads) {
      const testUrl = new URL(test.path, url).toString();
      const response = await axios.get(testUrl, {
        validateStatus: false,
        timeout: 5000,
        maxRedirects: 0
      });
      
      // WAF imzalarını kontrol et
      const headers = response.headers;
      const body = typeof response.data === 'string' ? response.data : '';
      
      // Yaygın WAF başlıkları ve içerik imzaları
      const wafSignatures = [
        { name: 'Cloudflare', headers: ['cf-ray', 'cf-cache-status'], body: ['cloudflare', 'ray id:'] },
        { name: 'AWS WAF', headers: ['x-amzn-waf'], body: ['aws', 'reference id:'] },
        { name: 'ModSecurity', headers: [], body: ['mod_security', 'not acceptable'] },
        { name: 'Imperva', headers: ['x-iinfo'], body: ['imperva', 'incapsula'] },
        { name: 'Akamai', headers: ['x-akamai-transformed'], body: ['akamai', 'reference'] },
        { name: 'F5 BIG-IP', headers: [], body: ['the requested url was rejected', 'please consult with your administrator'] },
        { name: 'Sucuri', headers: ['x-sucuri-id'], body: ['sucuri', 'access denied'] }
      ];
      
      // WAF imzalarını kontrol et
      for (const waf of wafSignatures) {
        // Başlıkları kontrol et
        const hasWafHeaders = waf.headers.some(h => headers[h]);
        
        // İçeriği kontrol et
        const hasWafBody = waf.body.some(b => body.toLowerCase().includes(b));
        
        if (hasWafHeaders || hasWafBody) {
          wafDetected = true;
          wafType = waf.name;
          wafEvidence = hasWafHeaders 
            ? `Detected WAF headers: ${waf.headers.filter(h => headers[h]).join(', ')}` 
            : `Detected WAF signature in response body`;
          break;
        }
      }
      
      // HTTP durum kodlarını kontrol et
      if (!wafDetected && (response.status === 403 || response.status === 406 || response.status === 429)) {
        // Saldırı imzası içeren istek 403/406/429 döndürdüyse muhtemelen WAF var
        wafDetected = true;
        wafType = 'Generic WAF';
        wafEvidence = `Blocked ${test.type} test with status code ${response.status}`;
      }
      
      if (wafDetected) break;
    }
    
    return { wafDetected, wafType, wafEvidence };
  } catch (error) {
    console.error('WAF detection error:', error.message);
    return { wafDetected: false, wafType: 'Unknown', wafEvidence: '' };
  }
}

// DNS kayıtlarını kontrol et
async function checkDNSRecords(hostname) {
  try {
    // MX kayıtları
    const getMXRecords = async () => {
      try {
        return await dnsResolve(hostname, 'MX');
      } catch (e) {
        return [];
      }
    };
    
    // TXT kayıtları
    const getTXTRecords = async () => {
      try {
        return await dnsResolve(hostname, 'TXT');
      } catch (e) {
        return [];
      }
    };
    
    // NS kayıtları
    const getNSRecords = async () => {
      try {
        return await dnsResolve(hostname, 'NS');
      } catch (e) {
        return [];
      }
    };
    
    // A kayıtları
    const getARecords = async () => {
      try {
        return await dnsResolve(hostname, 'A');
      } catch (e) {
        return [];
      }
    };
    
    // AAAA kayıtları
    const getAAAARecords = async () => {
      try {
        return await dnsResolve(hostname, 'AAAA');
      } catch (e) {
        return [];
      }
    };
    
    // Tüm kayıtları paralel olarak al
    const [mxRecords, txtRecords, nsRecords, aRecords, aaaaRecords] = await Promise.all([
      getMXRecords(),
      getTXTRecords(),
      getNSRecords(),
      getARecords(),
      getAAAARecords()
    ]);
    
    // SPF, DKIM, DMARC kontrolü
    const hasSPF = txtRecords.some(record => record.join('').includes('v=spf1'));
    const hasDKIM = txtRecords.some(record => record.join('').includes('v=DKIM1'));
    const hasDMARC = txtRecords.some(record => record.join('').includes('v=DMARC1'));
    
    // Güvenlik açıkları
    const issues = [];
    
    // SPF kontrolü
    if (!hasSPF && mxRecords.length > 0) {
      issues.push({
        id: `DNS-${Math.random().toString(36).substr(2, 9)}`,
        title: 'Missing SPF Record',
        severity: 'Medium',
        cvssScore: 5.0,
        description: 'E-posta sunucusu tespit edildi ancak SPF kaydı bulunamadı. Bu, e-posta sahteciliğine (spoofing) karşı koruma eksikliği anlamına gelir.',
        affectedComponents: `${hostname} - DNS Records`,
        remediation: 'SPF kaydı ekleyin (örn: "v=spf1 mx ~all")'
      });
    }
    
    // DMARC kontrolü
    if (!hasDMARC && mxRecords.length > 0) {
      issues.push({
        id: `DNS-${Math.random().toString(36).substr(2, 9)}`,
        title: 'Missing DMARC Record',
        severity: 'Medium',
        cvssScore: 5.0,
        description: 'E-posta sunucusu tespit edildi ancak DMARC kaydı bulunamadı. Bu, e-posta sahteciliğine (spoofing) karşı koruma eksikliği anlamına gelir.',
        affectedComponents: `${hostname} - DNS Records`,
        remediation: 'DMARC kaydı ekleyin (örn: "v=DMARC1; p=none; rua=mailto:dmarc@example.com")'
      });
    }
    
    // Açık DNS sunucuları
    if (nsRecords.length === 0) {
      issues.push({
        id: `DNS-${Math.random().toString(36).substr(2, 9)}`,
        title: 'Missing NS Records',
        severity: 'Low',
        cvssScore: 3.0,
        description: 'NS kayıtları bulunamadı. Bu, DNS yapılandırmasında bir sorun olduğunu gösterebilir.',
        affectedComponents: `${hostname} - DNS Records`,
        remediation: 'DNS yapılandırmanızı kontrol edin ve geçerli NS kayıtları ekleyin.'
      });
    }
    
    return {
      records: {
        mx: mxRecords,
        txt: txtRecords,
        ns: nsRecords,
        a: aRecords,
        aaaa: aaaaRecords
      },
      security: {
        hasSPF,
        hasDKIM,
        hasDMARC
      },
      issues
    };
  } catch (error) {
    console.error('DNS check error:', error.message);
    return { 
      records: {}, 
      security: { hasSPF: false, hasDKIM: false, hasDMARC: false },
      issues: []
    };
  }
}

export default async function handler(req, res) {
  if (req.method !== 'POST') {
    return res.status(405).json({ message: 'Method not allowed' });
  }

  const { target, scanType, advancedOptions } = req.body;

  if (!target) {
    return res.status(400).json({ message: 'Hedef belirtilmedi' });
  }

  try {
    // URL formatını düzenle ve sondaki / karakterini kontrol et
    let formattedTarget = target.startsWith('http') ? target : `https://${target}`;
    
    // URL'nin geçerli olup olmadığını kontrol et
    try {
      const urlObj = new URL(formattedTarget);
      // URL nesnesini string'e çevirirken sondaki / karakteri korunur
      formattedTarget = urlObj.toString();
    } catch (error) {
      return res.status(400).json({ 
        message: 'Geçersiz URL formatı',
        error: error.message 
      });
    }
    
    // Tarama seçeneklerini ayarla
    const scanOptions = {
      timeout: (advancedOptions?.timeout || 30) * 1000,
      maxRedirects: advancedOptions?.followRedirects ? 5 : 0,
      validateStatus: false,
      headers: {
        'User-Agent': advancedOptions?.customUserAgent || 'ReanzaiSecurityScanner/1.0'
      }
    };

    // Özel HTTP başlıklarını ekle
    if (advancedOptions?.customHeaders) {
      const customHeaders = advancedOptions.customHeaders
        .split('\n')
        .filter(line => line.trim())
        .reduce((headers, line) => {
          const [key, value] = line.split(':').map(part => part.trim());
          if (key && value) {
            headers[key] = value;
          }
          return headers;
        }, {});
      
      scanOptions.headers = { ...scanOptions.headers, ...customHeaders };
    }
    
    // Tarama başlangıç zamanı
    const scanStartTime = new Date();
    
    // Gerçek tarama işlemi
    const vulnerabilities = [];
    let technologies = [];
    let headers = {};
    let dnsInfo = {};
    let wafInfo = { wafDetected: false, wafType: 'Unknown', wafEvidence: '' };
    let corsInfo = { corsHeaders: {}, issues: [] };
    
    try {
      // Ana sayfa kontrolü
      console.log(`Scanning target: ${formattedTarget}`);
      const mainPageResponse = await axios.get(formattedTarget, scanOptions);
      
      // HTTP başlıklarını kaydet
      headers = mainPageResponse.headers;
      
      if (mainPageResponse.status >= 200 && mainPageResponse.status < 400) {
        // Teknoloji tespiti
        if (advancedOptions?.techDetection !== false) {
          console.log('Detecting technologies...');
          technologies = await detectTechnologies(formattedTarget);
          console.log(`Detected ${technologies.length} technologies`);
          
          // Tespit edilen teknolojiler için CVE kontrolü
          if (advancedOptions?.vulnCheck !== false) {
            console.log('Checking CVEs for detected technologies...');
            for (const tech of technologies) {
              if (tech.version !== 'Unknown') {
                const cveResults = await getCVEData(`${tech.name} ${tech.version}`, 3);
                console.log(`Found ${cveResults.length} CVEs for ${tech.name} ${tech.version}`);
                vulnerabilities.push(...cveResults.map(cve => ({
                  ...cve,
                  title: `${tech.name} ${tech.version} - ${cve.title}`,
                  affectedComponents: `${formattedTarget} - ${tech.name} ${tech.version}`
                })));
              }
            }
          }
        }

        // WAF tespiti
        if (advancedOptions?.wafDetection !== false) {
          console.log('Detecting WAF...');
          wafInfo = await detectWAF(formattedTarget);
          if (wafInfo.wafDetected) {
            console.log(`Detected WAF: ${wafInfo.wafType}`);
          }
        }
        
        // CORS kontrolü
        if (advancedOptions?.corsCheck !== false) {
          console.log('Checking CORS configuration...');
          corsInfo = await checkCORS(formattedTarget);
          if (corsInfo.issues.length > 0) {
            console.log(`Found ${corsInfo.issues.length} CORS issues`);
            vulnerabilities.push(...corsInfo.issues.map(issue => ({
              id: `CORS-${Math.random().toString(36).substr(2, 9)}`,
              title: issue.title,
              severity: issue.severity,
              cvssScore: issue.cvssScore,
              description: issue.description,
              affectedComponents: `${formattedTarget} - CORS Configuration`,
              remediation: issue.remediation
            })));
          }
        }
        
        // DNS kayıtları kontrolü
        if (advancedOptions?.dnsCheck !== false) {
          const hostname = new URL(formattedTarget).hostname;
          console.log(`Checking DNS records for ${hostname}...`);
          dnsInfo = await checkDNSRecords(hostname);
          if (dnsInfo.issues.length > 0) {
            console.log(`Found ${dnsInfo.issues.length} DNS issues`);
            vulnerabilities.push(...dnsInfo.issues);
          }
        }

        // Dizin taraması
        if (advancedOptions?.dirBruteforce || scanType === 'full') {
          console.log('Starting directory bruteforce...');
          // Temel dizinler
          const basePaths = [
            '/admin', '/wp-admin', '/phpmyadmin', '/backup', '/config',
            '/test', '/dev', '/api', '/login', '/wp-content',
            '/administrator', '/panel', '/admin-panel', '/dashboard',
            '/uploads', '/install', '/setup', '/console', '/system'
          ];
          
          // Gelişmiş dizinler (tam tarama için)
          const advancedPaths = scanType === 'full' ? [
            '/.git', '/.env', '/wp-config.php', '/config.php', '/database.php',
            '/server-status', '/server-info', '/phpinfo.php', '/info.php',
            '/robots.txt', '/sitemap.xml', '/readme.html', '/license.txt',
            '/wp-includes', '/wp-json', '/xmlrpc.php', '/wp-login.php',
            '/cpanel', '/webmail', '/mail', '/mysql', '/myadmin',
            '/private', '/secret', '/hidden', '/backup', '/old',
            '/temp', '/tmp', '/logs', '/log', '/error_log',
            '/cgi-bin', '/status', '/phpMyAdmin', '/pma', '/db'
          ] : [];
          
          // Özel dizinler
          const customPaths = (advancedOptions?.customPaths || '')
            .split('\n')
            .filter(p => p.trim());
          
          // Tüm dizinleri birleştir
          const pathsToCheck = [...new Set([...basePaths, ...advancedPaths, ...customPaths])];
          console.log(`Checking ${pathsToCheck.length} directories...`);
          
          // Eşzamanlı istek sayısı
          const concurrentRequests = 5;
          
          // Dizinleri gruplar halinde tara
          for (let i = 0; i < pathsToCheck.length; i += concurrentRequests) {
            const pathGroup = pathsToCheck.slice(i, i + concurrentRequests);
            const promises = pathGroup.map(path => {
              const pathUrl = `${formattedTarget}${path}`;
              return axios.get(pathUrl, {
                ...scanOptions,
                timeout: 3000
              })
              .then(response => {
                if (response.status !== 404 && response.status !== 403) {
                  vulnerabilities.push({
                    id: `PATH-${Math.random().toString(36).substr(2, 9)}`,
                    title: `Sensitive Directory Found: ${path}`,
                    severity: path.includes('admin') || path.includes('.git') || path.includes('.env') ? 'High' : 'Medium',
                    cvssScore: path.includes('admin') || path.includes('.git') || path.includes('.env') ? 7.5 : 5.0,
                    description: `Hassas dizin tespit edildi: ${path}. Bu dizin yetkisiz erişime açık olabilir.`,
                    affectedComponents: pathUrl,
                    remediation: 'Bu dizini kaldırın veya erişimi kısıtlayın.'
                  });
                  return { path, status: response.status };
                }
                return null;
              })
              .catch(() => null);
            });
            
            await Promise.all(promises);
          }
          
          console.log(`Directory scan completed. Found ${vulnerabilities.filter(v => v.id.startsWith('PATH')).length} sensitive directories.`);
        }

        // Port taraması
        if (advancedOptions?.portScan || scanType === 'full') {
          console.log('Starting port scan...');
          const hostname = new URL(formattedTarget).hostname;
          const { vulnerabilities: portVulns, openPorts } = await scanPorts(hostname);
          console.log(`Port scan completed. Found ${openPorts.length} open ports.`);
          vulnerabilities.push(...portVulns);
        }

        // SSL/TLS kontrolü
        if (advancedOptions?.sslCheck !== false && formattedTarget.startsWith('https://')) {
          console.log('Checking SSL/TLS configuration...');
          try {
            const sslInfo = await checkSSL(formattedTarget);
            if (sslInfo.issues.length > 0) {
              console.log(`Found ${sslInfo.issues.length} SSL/TLS issues.`);
              vulnerabilities.push(...sslInfo.issues.map(issue => ({
                id: `SSL-${Math.random().toString(36).substr(2, 9)}`,
                title: issue.title,
                severity: issue.severity,
                cvssScore: issue.cvssScore,
                description: issue.description,
                affectedComponents: `${formattedTarget} - SSL/TLS`,
                remediation: issue.remediation
              })));
            }
          } catch (error) {
            console.error('SSL check error:', error);
          }
        }

        // HTTP başlık kontrolü
        if (advancedOptions?.headerCheck !== false) {
          console.log('Checking HTTP headers...');
          const securityHeaders = [
            {
              header: 'X-Frame-Options',
              severity: 'Medium',
              cvssScore: 5.0,
              description: 'Clickjacking saldırılarına karşı koruma eksik'
            },
            {
              header: 'X-XSS-Protection',
              severity: 'Medium',
              cvssScore: 5.0,
              description: 'XSS koruması eksik'
            },
            {
              header: 'Content-Security-Policy',
              severity: 'High',
              cvssScore: 7.0,
              description: 'İçerik Güvenliği Politikası eksik'
            },
            {
              header: 'Strict-Transport-Security',
              severity: 'High',
              cvssScore: 7.0,
              description: 'HSTS politikası eksik'
            },
            {
              header: 'X-Content-Type-Options',
              severity: 'Low',
              cvssScore: 3.0,
              description: 'X-Content-Type-Options başlığı eksik'
            },
            {
              header: 'Referrer-Policy',
              severity: 'Low',
              cvssScore: 3.0,
              description: 'Referrer-Policy başlığı eksik'
            },
            {
              header: 'Permissions-Policy',
              severity: 'Low',
              cvssScore: 3.0,
              description: 'Permissions-Policy başlığı eksik'
            }
          ];

          for (const header of securityHeaders) {
            if (!headers[header.header.toLowerCase()]) {
              vulnerabilities.push({
                id: `HEADER-${Math.random().toString(36).substr(2, 9)}`,
                title: `Missing ${header.header} Header`,
                severity: header.severity,
                cvssScore: header.cvssScore,
                description: header.description,
                affectedComponents: `${formattedTarget} - HTTP Headers`,
                remediation: `${header.header} başlığını ekleyin ve uygun şekilde yapılandırın.`
              });
            }
          }

          // Information disclosure kontrolü
          const sensitiveHeaders = ['server', 'x-powered-by', 'x-aspnet-version', 'x-runtime'];
          for (const header of sensitiveHeaders) {
            if (headers[header]) {
              vulnerabilities.push({
                id: `INFO-${Math.random().toString(36).substr(2, 9)}`,
                title: `Information Disclosure: ${header} Header`,
                severity: 'Low',
                cvssScore: 3.0,
                description: `${header} başlığı versiyon bilgisi ifşa ediyor: ${headers[header]}`,
                affectedComponents: `${formattedTarget} - HTTP Headers`,
                remediation: `${header} başlığını gizleyin veya içeriğini değiştirin.`
              });
            }
          }
          
          console.log(`Header check completed. Found ${vulnerabilities.filter(v => v.id.startsWith('HEADER') || v.id.startsWith('INFO')).length} header issues.`);
        }
        
        // XSS ve SQL Injection kontrolü (tam tarama için)
        if (scanType === 'full') {
          console.log('Checking for XSS and SQL Injection vulnerabilities...');
          // Form tespiti ve test
          try {
            const html = mainPageResponse.data;
            if (typeof html === 'string') {
              // Form tespiti
              const formRegex = /<form[^>]*action=["']([^"']*)["'][^>]*>/gi;
              let formMatch;
              const formUrls = [];
              
              while ((formMatch = formRegex.exec(html)) !== null) {
                const formAction = formMatch[1];
                const formUrl = formAction.startsWith('http') 
                  ? formAction 
                  : formAction.startsWith('/') 
                    ? `${new URL(formattedTarget).origin}${formAction}`
                    : `${formattedTarget}${formAction}`;
                
                formUrls.push(formUrl);
              }
              
              if (formUrls.length > 0) {
                vulnerabilities.push({
                  id: `FORM-${Math.random().toString(36).substr(2, 9)}`,
                  title: `Form Detected: Potential Input Validation Vulnerability`,
                  severity: 'Medium',
                  cvssScore: 6.0,
                  description: `${formUrls.length} form(lar) tespit edildi. Bu formlar XSS veya SQL Injection saldırılarına açık olabilir.`,
                  affectedComponents: formUrls.join(', '),
                  remediation: 'Tüm kullanıcı girdilerini doğrulayın ve temizleyin. Parametreli sorgular kullanın ve XSS koruması uygulayın.'
                });
              }
            }
          } catch (error) {
            console.error('Form detection error:', error);
          }
        }
      }
    } catch (error) {
      return res.status(400).json({ 
        message: `Hedef URL'ye erişilemiyor: ${error.message}`,
        error: error.message 
      });
    }

    // Tarama bitiş zamanı ve süre hesaplama
    const scanEndTime = new Date();
    const scanDuration = Math.round((scanEndTime - scanStartTime) / 1000);

    // Tarama tipine göre sonuçları filtrele
    let filteredVulnerabilities = vulnerabilities;
    if (scanType === 'quick') {
      filteredVulnerabilities = vulnerabilities.filter(v => 
        v.severity === 'Critical' || v.severity === 'High'
      );
    } else if (scanType === 'standard') {
      filteredVulnerabilities = vulnerabilities.filter(v => 
        v.severity === 'Critical' || v.severity === 'High' || v.severity === 'Medium'
      );
    }

    // Sonuçları hazırla
    const scanResults = {
      target: formattedTarget,
      scanType,
      scanDuration,
      timestamp: new Date().toISOString(),
      vulnerabilities: filteredVulnerabilities,
      technologies,
      headers,
      waf: wafInfo.wafDetected ? {
        detected: true,
        type: wafInfo.wafType,
        evidence: wafInfo.wafEvidence
      } : {
        detected: false
      },
      cors: corsInfo.corsHeaders,
      dns: dnsInfo.records,
      dnsSecurityInfo: dnsInfo.security,
      summary: {
        critical: filteredVulnerabilities.filter(v => v.severity === 'Critical').length,
        high: filteredVulnerabilities.filter(v => v.severity === 'High').length,
        medium: filteredVulnerabilities.filter(v => v.severity === 'Medium').length,
        low: filteredVulnerabilities.filter(v => v.severity === 'Low').length
      }
    };

    // Sonuçları geçmişe kaydet
    try {
      // Tarama sonuçlarını geçmişe kaydet
      const apiUrl = process.env.NODE_ENV === 'production' 
        ? `${req.headers['x-forwarded-proto'] || 'http'}://${req.headers.host}/api/scan-history`
        : 'http://localhost:3000/api/scan-history';
      
      console.log(`Saving scan results to history API: ${apiUrl}`);
      
      // Tarama sonuçlarını kopyala ve büyük nesneleri sınırla
      const historyData = {
        ...scanResults,
        // Çok büyük veri yapılarını sınırla
        vulnerabilities: scanResults.vulnerabilities.map(v => ({
          id: v.id,
          title: v.title,
          severity: v.severity,
          cvssScore: v.cvssScore,
          description: v.description.substring(0, 500), // Açıklamayı sınırla
          affectedComponents: v.affectedComponents,
          remediation: v.remediation,
          // Referansları sınırla
          references: v.references ? v.references.slice(0, 3) : []
        })),
        // HTTP başlıklarını sınırla
        headers: Object.fromEntries(
          Object.entries(scanResults.headers || {}).slice(0, 20)
        )
      };
      
      const response = await axios.post(apiUrl, historyData, {
        headers: {
          'Content-Type': 'application/json'
        },
        timeout: 10000
      });
      
      console.log(`Scan history saved successfully. Status: ${response.status}`);
    } catch (error) {
      console.error('Failed to save scan history:', error.message);
      if (error.response) {
        console.error(`Response status: ${error.response.status}, data:`, error.response.data);
      } else if (error.request) {
        console.error('No response received from server');
      } else {
        console.error('Error creating request:', error.message);
      }
      // Geçmiş kaydetme hatası tarama sonucunu etkilemez, devam et
    }

    return res.status(200).json(scanResults);
  } catch (error) {
    console.error('Vulnerability scan error:', error);
    return res.status(500).json({ 
      message: 'Tarama sırasında bir hata oluştu',
      error: error.message 
    });
  }
} 